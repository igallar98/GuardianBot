sudo mount -t bpf bpf /sys/fs/bpf/

sudo ./xdp_loader --skb-mode --dev wlp4s0 --force --progsec xdp_pass
sudo ./xdp_stats --dev wlp4s0
/* SPDX-License-Identifier: GPL-2.0 */
#include <linux/bpf.h>
#include <bpf/bpf_helpers.h>
#include <bpf/bpf_endian.h>
#include <stdio.h>


#include "maps_kern.h"



static __always_inline
__u32 xdp_stats_record_action(struct xdp_md *ctx)
{
	void *data_end = (void *)(long)ctx->data_end;
	void *data     = (void *)(long)ctx->data;

	int ip_type, eth_type;
	struct ethhdr *eth;
	struct hdr_cursor nh;
	struct iphdr *iph;
	struct ipv6hdr *ipv6hdr;
	/*struct icmphdr_common *icmphdr;*/
	struct udphdr *udphdr;
	struct tcphdr *tcphdr;
	struct keyip key = {};
	int tcp_type, udp_type;


	struct datarec aux = {0, 0, 0, 0, 0, XDP_PASS};
	struct record auxrec = {{0, 0}, {{0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0}}};

	aux.status = XDP_PASS;


	/* Packet parsing */
	nh.pos = data;

	eth_type = parse_ethhdr(&nh, data_end, &eth);

	if (eth_type == bpf_htons(ETH_P_IP)) {
			ip_type = parse_iphdr(&nh, data_end, &iph);

			if(ip_type == -1)
				return aux.status;

			key.ip_saddr = iph->saddr;
			key.ip_daddr = iph->daddr;
			key.isv6 = 0;

	} else if (eth_type == bpf_htons(ETH_P_IPV6)){
			ip_type = parse_ip6hdr(&nh, data_end, &ipv6hdr);

			if(ip_type == -1)
					return aux.status;

				key.ip6_saddr = ipv6hdr->saddr;
				key.ip6_daddr = ipv6hdr->daddr;
				key.isv6 = 1;

				aux.protocol = ip_type;

	} else {
		return aux.status;
	}


	switch(ip_type) {

	 case IPPROTO_ICMPV6 || IPPROTO_ICMP:
			/*icmp_type = parse_icmphdr_common(&nh, data_end, &icmphdr);*/

			break;

	 case IPPROTO_TCP:
		 tcp_type = parse_tcphdr(&nh, data_end, &tcphdr);
		 aux.source = tcphdr->source;
		 aux.dest = tcphdr->dest;
		 break;

		case IPPROTO_UDP:
		udp_type = parse_udphdr(&nh, data_end, &udphdr);
		aux.source = udphdr->source;
		aux.dest = udphdr->dest;
		break;
	}

	/* Update packet length */
	__u64 bytes = data_end - data;



	struct datarec * rec = bpf_map_lookup_elem(&xdp_data_map, &key);
	if(!rec) {
		bpf_map_update_elem(&xdp_data_map, &key, &aux, BPF_NOEXIST);
		bpf_map_update_elem(&xdp_data_map_s, &key, &auxrec, BPF_NOEXIST);
		return aux.status;
	}
	aux.rx_packets = rec->rx_packets;
	aux.rx_bytes = rec->rx_bytes;


	aux.rx_packets++;
	aux.rx_bytes += bytes;

	bpf_map_update_elem(&xdp_data_map, &key, &aux, BPF_ANY);

	return aux.status;
}

SEC("xdp_pass")
int  xdp_pass_func(struct xdp_md *ctx)
{
	return xdp_stats_record_action(ctx);
}
/* DATA IP MAP PER CPU */
struct datarec {
	__u64 rx_packets;
	__u64 rx_bytes;
	int protocol;
	__u16   source;
	__u16   dest;
	__u32 status;

};
char _license[] SEC("license") = "GPL";
